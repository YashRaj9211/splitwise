generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// USER
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  username  String   @unique
  password  String
  phone     String?
  avatarUrl String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Personal expenses created by user
  expenses Expense[]

  // Group memberships
  groupMembers GroupMember[]

  // Split participations (what user owes or is owed)
  splits ExpenseSplit[]

  // Friendships initiated by user
  friendshipsInitiated Friendship[] @relation("FriendshipInitiator")

  // Friendships received by user
  friendshipsReceived Friendship[] @relation("FriendshipReceiver")

  // Payments made by user
  paymentsMade Payment[] @relation("PaymentPayer")

  // Payments received by user
  paymentsReceived Payment[] @relation("PaymentReceiver")

  @@index([email])
}

// Friendship model for managing friend connections
model Friendship {
  id        String           @id @default(cuid())
  userId    String
  friendId  String
  status    FriendshipStatus @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  user   User @relation("FriendshipInitiator", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("FriendshipReceiver", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@index([userId])
  @@index([friendId])
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum GroupRole {
  ADMIN
  MEMBER
}

// Group model for splitting expenses among common friends
model Group {
  id            String   @id @default(cuid())
  name          String
  description   String?
  imageUrl      String?
  simplifyDebts Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  members  GroupMember[]
  expenses Expense[]

  @@index([name])
}

// GroupMember model for managing group memberships
model GroupMember {
  id       String    @id @default(cuid())
  groupId  String
  userId   String
  role     GroupRole @default(MEMBER)
  joinedAt DateTime  @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
}

// Category model for expense categorization
model Category {
  id        String   @id @default(cuid())
  name      String   @unique
  icon      String?
  color     String?
  createdAt DateTime @default(now())

  expenses Expense[]

  @@index([name])
}

// Main Expense model
model Expense {
  id          String      @id @default(cuid())
  amount      Decimal     @db.Decimal(12, 2)
  currency    String      @default("INR")
  description String
  note        String?
  type        ExpenseType
  expenseDate DateTime
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  groupId String?
  group   Group?  @relation(fields: [groupId], references: [id], onDelete: SetNull)

  // Split information
  splits ExpenseSplit[]

  // Payment tracking
  payments Payment[]

  @@index([userId])
  @@index([categoryId])
  @@index([groupId])
  @@index([expenseDate])
  @@index([type])
}

enum ExpenseType {
  PERSONAL // Personal expense (no splitting)
  SPLIT // Split expense among friends/group
  INCOME // Income entry
}

// ExpenseSplit model for tracking how expense is split
model ExpenseSplit {
  id         String    @id @default(cuid())
  expenseId  String
  userId     String
  amount     Decimal   @db.Decimal(12, 2)
  splitType  SplitType
  percentage Decimal?  @db.Decimal(5, 2) // For percentage splits
  isPaid     Boolean   @default(false)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  expense Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([expenseId, userId])
  @@index([expenseId])
  @@index([userId])
  @@index([isPaid])
}

enum SplitType {
  EQUAL // Split equally among all participants
  EXACT // Exact amount specified for each participant
  PERCENTAGE // Split by percentage
  SHARES // Split by shares/ratio
}

// Payment model for tracking settlements between users
model Payment {
  id          String   @id @default(cuid())
  amount      Decimal  @db.Decimal(12, 2)
  currency    String   @default("USD")
  description String?
  paymentDate DateTime @default(now())
  createdAt   DateTime @default(now())

  payerId String
  payer   User   @relation("PaymentPayer", fields: [payerId], references: [id], onDelete: Cascade)

  receiverId String
  receiver   User   @relation("PaymentReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  expenseId String?
  expense   Expense? @relation(fields: [expenseId], references: [id], onDelete: SetNull)

  @@index([payerId])
  @@index([receiverId])
  @@index([expenseId])
  @@index([paymentDate])
}

// Optional: Budget model for tracking spending limits
model Budget {
  id         String       @id @default(cuid())
  userId     String
  categoryId String?
  amount     Decimal      @db.Decimal(12, 2)
  period     BudgetPeriod
  startDate  DateTime
  endDate    DateTime
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  @@index([userId])
  @@index([categoryId])
  @@index([startDate, endDate])
}

enum BudgetPeriod {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
  CUSTOM
}
